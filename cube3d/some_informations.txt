INFORMATIONS

- Ajouter une structure (ex: "s_toto"):
		
		# Creer la structure dans la structure PRINCIPALE "data" (t_data)
			typedef struct s_toto
			{
			contenu de la structure s_toto;
			}	t_toto;
		
		# Malloc cette structure dans "init_data(t_data *data, char **argv)"
			 ==> data->toto = (t_toto *)malloc(sizeof(t_toto));

		# Initialiser cette structure, toujours dans "init_data(t_data *data, char **argv)"
			!! en ayant cree une fonction specifique :
				init_toto(data->toto, //si besoin "data", et tout ce dont on peut avoir besoin);
		
		  void	init_toto(t_toto *toto, // tout ce que besoin vous// )
		  {
		  data->pos_x = 0.0;
		  data->pos_y = 0.0;
		  data->texture_txt[0] = NULL;
		  data->texture_txt[1] = NULL;
		  data->texture_txt[2] = NULL;
		  data->texture_txt[3] = NULL;
		  data->F = NULL;
		  data->C = NULL;
		  data->map = NULL;
	  	  }

		#Free data->toto dans "int	exit_manager(t_data *data)"
		   avec une fonction specifique 
		   		void	free_map_data(t_map_data *map_data)
				{
					int	x;

					x = 0;
					if (map_data->map)
						free_tab(map_data->map);
					if (map_data->C)
						free(map_data->C);
					if (map_data->F)
						free(map_data->F);
					while (x < 4)
					{
						free(map_data->texture_txt[x]);
						x++;
					}
					free(map_data);
				}

- Si textures a ajouter:
		# les ajouter dans le fichier .cub  ==> "TO ./texture/toto1.xpm"

		# Augmenter la taille du tableau de char dans map_data pour les y ajouter.

		# les initialiser dans "void	init_map_data(t_map_data *data, char **argv)"

		# changer la taille dans "void	init_mlx_data(t_mlx_data *data, char *texture[4])"
				et le "< 4"
		
		# ajouter a "int	init_textures(t_map_data *map_data, int fd, int trigger, int x)"
		# ajouter a "int	check_error(t_data *data, t_map_data map_data)"

		# modifier dans ft_render.














FT_render avec ennemies et objets avec fond vert

int	ft_render(t_data *data)
{
	int	x;
	int	y;
	int	count;
	int	collectible_index;
	int tex_index;
	//int tex_index2;

	x = 0;
	count = 0;

	while (x < SCREEN_WIDTH)
	{
		if (count == SCREEN_HEIGHT)
			count = 0;

		// Calcul des rayons pour chaque colonne de l'écran
		data->trace_data->cameraX = 2 * x / (double)SCREEN_WIDTH - 1;
		data->trace_data->rayDirX = data->trace_data->dirX + data->trace_data->planeX * data->trace_data->cameraX;
		data->trace_data->rayDirY = data->trace_data->dirY + data->trace_data->planeY * data->trace_data->cameraX;
		data->trace_data->mapX = (int)data->map_data->pos_x;
		data->trace_data->mapY = (int)data->map_data->pos_y;

		// Initialisation des distances
		if (data->trace_data->rayDirX == 0)
			data->trace_data->deltaDistX = 1e30;
		else
			data->trace_data->deltaDistX = ft_abs(1 / data->trace_data->rayDirX);

		if (data->trace_data->rayDirY == 0)
			data->trace_data->deltaDistY = 1e30;
		else
			data->trace_data->deltaDistY = ft_abs(1 / data->trace_data->rayDirY);

		data->trace_data->hit = 0;

		// Calcul des steps et sideDist
		if (data->trace_data->rayDirX < 0)
		{
			data->trace_data->stepX = -1;
			data->trace_data->sideDistX = (data->map_data->pos_x - data->trace_data->mapX) * data->trace_data->deltaDistX;
		}
		else
		{
			data->trace_data->stepX = 1;
			data->trace_data->sideDistX = (data->trace_data->mapX + 1.0 - data->map_data->pos_x) * data->trace_data->deltaDistX;
		}
		if (data->trace_data->rayDirY < 0)
		{
			data->trace_data->stepY = -1;
			data->trace_data->sideDistY = (data->map_data->pos_y - data->trace_data->mapY) * data->trace_data->deltaDistY;
		}
		else
		{
			data->trace_data->stepY = 1;
			data->trace_data->sideDistY = (data->trace_data->mapY + 1.0 - data->map_data->pos_y) * data->trace_data->deltaDistY;
		}




// Boucle de DDA pour trouver la distance au mur ou à la porte
while (data->trace_data->hit == 0)
{
    if (data->trace_data->sideDistX < data->trace_data->sideDistY)
    {
        data->trace_data->sideDistX += data->trace_data->deltaDistX;
        data->trace_data->mapX += data->trace_data->stepX;
        data->trace_data->side = 0;
    }
    else
    {
        data->trace_data->sideDistY += data->trace_data->deltaDistY;
        data->trace_data->mapY += data->trace_data->stepY;
        data->trace_data->side = 1;
    }

    char current_tile = data->map_data->map[data->trace_data->mapX][data->trace_data->mapY];
	

    if (current_tile == '1') // Collision avec un mur
    {
        data->trace_data->hit = 1;
    }
    else if (current_tile == 'D') // Collision avec une porte
    {
        if (data->bonus_data->door.is_open == 0) // Si la porte est fermée
        {
            // La porte fermée se comporte comme un mur
            data->trace_data->hit = 1;
        }
        else if (data->bonus_data->door.is_open == 1) // Si la porte est ouverte
        {
            // La porte ouverte doit être rendue mais le joueur peut passer à travers
            data->trace_data->hit = 1; // Rend la porte tout en permettant de traverser
        }
    }
	//!-------------------------------------------------------------------------
	else if (current_tile == 'C') // Collision avec un collectible
    {
        collectible_index = find_collectible_at(data->bonus_data, data->trace_data->mapX,
													data->trace_data->mapY);
		if (collectible_index != -1 && data->bonus_data->collectibles
						[collectible_index].is_collected == 0)// Si l'objet n'est pas collecte'
        {
			//printf("COLLEX INDEX == %d \n", collectible_index);
            // L'objet se voit comme un mur
            data->trace_data->hit = 1; //TODO pour afficher ou pas l'objet, ici 0 = pas afficher
        }
    }
	else if (current_tile == 'Z') // Collision avec un ennemy
    {
        collectible_index = find_ennemy_at(data->bonus_data, data->trace_data->mapX,
													data->trace_data->mapY);
		if (collectible_index != -1 && data->bonus_data->enemies
						[collectible_index].is_alive == 1)// Si l'ennemy n'est pas collecte'
        {
			//printf("ENEMYX INDEX == %d \n", ennemy_index);
            // L'ennemy se voit comme un mur
            data->trace_data->hit = 1; //TODO pour afficher ou pas l'objet, ici 0 = pas afficher
        }
    }
	//!-------------------------------------------------------------------------
}




		// Calcul de la distance perpendiculaire au mur
		if (data->trace_data->side == 0)
			data->trace_data->perpWallDist = (data->trace_data->sideDistX - data->trace_data->deltaDistX);
		else
			data->trace_data->perpWallDist = (data->trace_data->sideDistY - data->trace_data->deltaDistY);

		data->trace_data->lineHeight = (int)(SCREEN_HEIGHT / data->trace_data->perpWallDist);

		data->trace_data->drawStart = -data->trace_data->lineHeight / 2 + SCREEN_HEIGHT / 2;
		if (data->trace_data->drawStart < 0)
			data->trace_data->drawStart = 0;

		data->trace_data->drawEnd = data->trace_data->lineHeight / 2 + SCREEN_HEIGHT / 2;
		if (data->trace_data->drawEnd >= SCREEN_HEIGHT)
			data->trace_data->drawEnd = SCREEN_HEIGHT - 1;

		// Calcul de WallX pour déterminer quelle partie de la texture utiliser
		if (data->trace_data->side == 0)
			data->trace_data->WallX = data->map_data->pos_y + data->trace_data->perpWallDist * data->trace_data->rayDirY;
		else
			data->trace_data->WallX = data->map_data->pos_x + data->trace_data->perpWallDist * data->trace_data->rayDirX;
		data->trace_data->WallX -= floor(data->trace_data->WallX);

		// Calcul de la position X de la texture
		data->trace_data->texX = (int)(data->trace_data->WallX * (double)TEX_WIDTH);
		if (data->trace_data->side == 0 && data->trace_data->rayDirX > 0)
			data->trace_data->texX = TEX_WIDTH - data->trace_data->texX - 1;
		if (data->trace_data->side == 1 && data->trace_data->rayDirY < 0)
			data->trace_data->texX = TEX_HEIGHT - data->trace_data->texX - 1;

		data->trace_data->step = 1.0 * TEX_HEIGHT / data->trace_data->lineHeight;
		data->trace_data->texPos = (data->trace_data->drawStart - SCREEN_HEIGHT / 2 + data->trace_data->lineHeight / 2) * data->trace_data->step;


		// --------Dessiner le plafond--------------------
		y = 0;
		while (y < data->trace_data->drawStart)
		{
			data->trace_data->buffer[y][x] = data->map_data->F_color;
			y++;
		}
		//------------------------------------------
//!--------------------------------------------------------------------------------------
		// Détermination de la texture à utiliser en fonction du type de case
		//int tex_index;


		if (data->trace_data->side == 0 && data->trace_data->stepX == 1)
			tex_index = 0; // Texture du 1er mur
		else if (data->trace_data->side == 0 && data->trace_data->stepX == -1)
			tex_index = 1; // Texture du 2eme mur
		else if (data->trace_data->side == 1 && data->trace_data->stepY == 1)
			tex_index = 3; // Texture du 3eme mur
		else if (data->trace_data->side == 1 && data->trace_data->stepY == -1)
		tex_index = 2; // Texture du 4eme mur


		if (data->map_data->map[data->trace_data->mapX][data->trace_data->mapY] == 'D' && data->bonus_data->door.is_open == 0)
			tex_index = 6; // Texture de la porte
		if (data->map_data->map[data->trace_data->mapX][data->trace_data->mapY] == 'D' && data->bonus_data->door.is_open == 1)
			tex_index = 7; // Texture de la porte



		if (data->map_data->map[data->trace_data->mapX][data->trace_data->mapY] == 'C')
		{
			collectible_index = find_collectible_at(data->bonus_data, data->trace_data->mapX, data->trace_data->mapY);
			if (collectible_index != -1 && data->bonus_data->collectibles[collectible_index].is_collected == 0)
			{
				tex_index = 13;  // Texture du collectible non collecté
			}
		}

		if (data->map_data->map[data->trace_data->mapX][data->trace_data->mapY] == 'Z')
		{
			collectible_index = find_ennemy_at(data->bonus_data, data->trace_data->mapX, data->trace_data->mapY);
			if (collectible_index != -1 && data->bonus_data->enemies[collectible_index].is_alive == 1)
			{
				tex_index = 10;  // Texture de l'ennemy
			}
		}

		
		//!!!!!!!!-------------------------
		/*int r = 0;
		while (r < data->bonus_data->num_collectibles)
		{
			printf("Collectible #%d // index %d \n", r + 1, r);
			printf("C_x = %f | C_y = %f | Is_collected = %d\n", data->bonus_data->collectibles[r].c_x,
																data->bonus_data->collectibles[r].c_y,
																data->bonus_data->collectibles[r].is_collected);
			r++;
		}*/
		//!!!!!!!-------------------------



		// Rendu des pixels pour chaque colonne
		y = data->trace_data->drawStart;
		while (y < data->trace_data->drawEnd)
		{
			data->trace_data->texY = (int)data->trace_data->texPos & (TEX_HEIGHT - 1);
			data->trace_data->texPos += data->trace_data->step;
			data->trace_data->color = get_pixel(data->mlx_data->texture[tex_index], data->trace_data->texX, data->trace_data->texY);
			
			 // Vérifier si la couleur est verte (RGB = 0x00FF00)
			if (!is_near_green(data->trace_data->color, 110))
			{
				// Si la face est sur les côtés, on assombrit la couleur
				if (data->trace_data->side == 1)
				{
					data->trace_data->color = (data->trace_data->color >> 1) & 8355711; // Assombrir les côtés
				}

				// Dessiner le pixel dans le buffer
				data->trace_data->buffer[y][x] = data->trace_data->color;
			}
			/*if (data->trace_data->side == 1)
				data->trace_data->color = (data->trace_data->color >> 1) & 8355711; // Assombrir les côtés

			data->trace_data->buffer[y][x] = data->trace_data->color;*/
			y++;
		}


//!!--------------------------------------------------------------------------------------
		// Dessiner le sol
		while (y < SCREEN_HEIGHT)
		{
			data->trace_data->buffer[y][x] = data->map_data->C_color;
			y++;
		}
		x++;
	}
	//--------------------------------------

	

//TODO----------- afficher objets et ennemis par dessus la map ---------------------

	//render_collec_ennemies(data);

//TODO------------------------------------------------------------------------------
	
	// Affichage des buffers et effacement de l'écran
	draw_buffer(data->trace_data);
	y = 0;
	while (y < SCREEN_HEIGHT)
	{
		x = 0;
		while (x < SCREEN_WIDTH)
		{
			data->trace_data->buffer[y][x] = 0;
			x++;
		}
		y++;
	}

	// Appel au rendu de la minimap
	draw_minimap(data);

	// Afficher l'image sur la fenêtre
	mlx_put_image_to_window(data->mlx_data->mlx, data->mlx_data->window, data->mlx_data->img->img, 0, 0);
	return (0);
}